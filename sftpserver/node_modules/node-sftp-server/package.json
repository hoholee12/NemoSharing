{
  "_args": [
    [
      "node-sftp-server@git+https://github.com/hoholee12/node-sftp-server.git",
      "/home/jeongho/NemoSharing/sftpserver"
    ]
  ],
  "_from": "git+https://github.com/hoholee12/node-sftp-server.git",
  "_id": "node-sftp-server@0.3.0",
  "_inCache": true,
  "_installable": true,
  "_location": "/node-sftp-server",
  "_phantomChildren": {},
  "_requested": {
    "hosted": {
      "directUrl": "https://raw.githubusercontent.com/hoholee12/node-sftp-server/master/package.json",
      "gitUrl": "git://github.com/hoholee12/node-sftp-server.git",
      "httpsUrl": "git+https://github.com/hoholee12/node-sftp-server.git",
      "shortcut": "github:hoholee12/node-sftp-server",
      "ssh": "git@github.com:hoholee12/node-sftp-server.git",
      "sshUrl": "git+ssh://git@github.com/hoholee12/node-sftp-server.git",
      "type": "github"
    },
    "name": "node-sftp-server",
    "raw": "node-sftp-server@git+https://github.com/hoholee12/node-sftp-server.git",
    "rawSpec": "git+https://github.com/hoholee12/node-sftp-server.git",
    "scope": null,
    "spec": "git+https://github.com/hoholee12/node-sftp-server.git",
    "type": "hosted"
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git+https://github.com/hoholee12/node-sftp-server.git#825e11387051d026ee52eaee8076328a76c079cf",
  "_shasum": "cd254e1666150786029cfa98b6d8aad9426305e1",
  "_shrinkwrap": null,
  "_spec": "node-sftp-server@git+https://github.com/hoholee12/node-sftp-server.git",
  "_where": "/home/jeongho/NemoSharing/sftpserver",
  "author": {
    "email": "brady@briteverify.com",
    "name": "Brady Wetherington"
  },
  "bugs": {
    "url": "https://github.com/BriteVerify/node-sftp-server/issues"
  },
  "contributors": [
    {
      "name": "Jonathan Yarbor",
      "email": "jon@nodecraft.com",
      "url": "https://nodecraft.com"
    }
  ],
  "dependencies": {
    "ssh2": "0.5.x",
    "ssh2-streams": "^0.0.21",
    "tmp": "^0.0.30"
  },
  "description": "Node.js SFTP Server bindings to implement your own SFTP Server",
  "devDependencies": {},
  "gitHead": "825e11387051d026ee52eaee8076328a76c079cf",
  "homepage": "https://github.com/BriteVerify/node-sftp-server#readme",
  "keywords": [
    "sftp",
    "sftp-server"
  ],
  "license": "ISC",
  "main": "node-sftp-server.js",
  "name": "node-sftp-server",
  "optionalDependencies": {},
  "readme": "\n# node-sftp-server\n\nA simple interface to be able to implement an SFTP Server using Node.js. Based \non excellent work by [@mscdex](https://github.com/mscdex) - [ssh2](https://github.com/mscdex/ssh2) and [ssh2-streams](https://github.com/mscdex/ssh2-streams). Without\nwhich none of this would be possible.\n\nIn all cases, this library will only ever perform a subset of what can be \naccomplished with [ssh2](https://github.com/mscdex/ssh2). If there's something more advanced you need\nto do and this library won't support it, that one is probably the one to look \nat. And certainly pull requests would be welcome, too!\n\nThe easiest way to get the hang of this library is probably to look at the \n`server_example.js` to start with, until this documentation gets more fully\nfleshed-out.\n\n# Installation\n\n```\nnpm install --save node-sftp-server\n```\n\n# Usage\n\n```js\nvar SFTPServer=require('node-sftp-server');\n```\n\n## SFTPServer Object\n\n### constructor\n\n```js\nvar myserver = new SFTPServer({ privateKeyFile: \"path_to_private_key_file\" });\n```\n\nThis returns a new `SFTPServer()` object, which is an EventEmitter. If the private\nkey is not specified, the constructor will try to use `ssh_host_rsa_key` in the current directory.\n\n### debugging\n\nYou can supply a `debug: true` option to the constructor like this:\n\n```js\nvar myserver = new SFTPServer({\n    privateKeyFile: \"path_to_private_key_file\",\n    debug: true\n});\n```\n\nThe `debug` option turns on console logging for SSH2 streams so you can see what's going on under the\nhood to help debug authentication problems, or other low level issues you may encounter. \n\n### temporary files\n\nThe server stores temporary files while users are downloading. These are handled by the [tmp library](https://www.npmjs.com/package/tmp).\nPermissions for these files are set to 600 (read and write for the node user, no permission for any other users) and \nare stored in your platform's default temporary file location. You can control which directory these files appear in\nby passing the `temporaryFileDirectory` to the constructor like this:\n\n```js\nvar myserver = new SFTPServer({\n    privateKeyFile: \"path_to_private_key_file\",\n    temporaryFileDirectory: \"/some/temporary/file/path/here\"\n});\n```\n\n### methods \n```js\n.listen(portnumber)\n```\nListens for an SFTP client to connect to the server on this port.\n\n### events\n`connect` - passes along two parameters. The first is a simple context object which has - \n\n- username: \n- password:\n- method: \n\nThe second is a client-info parameter, which has elements like:\n{\"ip\":\"::1\",\"header\":{\"identRaw\":\"SSH-2.0-FileZilla_3.27.1\",\"versions\":{\"protocol\":\"2.0\",\"software\":\"FileZilla_3.27.1\"}}}\n- ip (the remote IP)\n- header\n  - identRaw (client identification string, like \"SSH-2.0-FileZilla_3.27.1\")\n  - versions\n    - protocol (example: \"2.0\")\n    - software (example: \"FileZilla_3.27.1\")\n\nWith the context object, you can call `.reject(methodsLeft, isPartial)` to reject the connection, or call `.accept(callback)`\nto work with the new connection. The accept callback will be passed a Session object\nas its parameter. The `methodsLeft` parameter is an array of acceptable authentication\nmethods, two of which are 'password' and 'none'. `isPartial` is whether or not the \nattempt should be considered a partial success.\n\n`end` - emitted when the user disconnects from the server.\n\n`error` - emitted when the ssh server throws an error. passes error object\n\n## Session Object\n\nThis object is passed to you when you call `.accept(callback)` - your callback\nshould expect to be passed a session object as a parameter. The session object\nis an EventEmitter as well.\n\n### events\n\n`.on(\"realpath\",function (path,callback) { })` - the server wants to determine the 'real' path\nfor some user. For instance, if a user, when they log in, is immediately deposited\ninto `/home/<username>/` - you could implement that here. Invoke the callback \nwith the calculated path - e.g. `callback(\"/home/\"+username)`.  *TODO* - Error \nmanagement here!\n\n`.on(\"stat\",function (path,statkind,statresponder) { })` - on any of STAT, LSTAT, or FSTAT\nrequests (the type will be passed in \"statkind\"). The statresponder object is a `Statter`\nobject from the source code. Communicate status back by calling methods and setting properties\non the object like this:\n\n#### Directory\n```js\nsession.on('stat', function(path, statkind, statresponder) {\n    statresponder.is_directory();      // Tells statresponder that we're describing a directory.\n    statresponder.permissions = 0o755; // Octal permissions, like what you'd send to a chmod command\n    statresponder.uid = 1;             // User ID that owns the file.\n    statresponder.gid = 1;             // Group ID that owns the file.\n    statresponder.size = 0;            // File size in bytes.\n    statresponder.atime = 123456;      // Created at (unix style timestamp in seconds-from-epoch).\n    statresponder.mtime = 123456;      // Modified at (unix style timestamp in seconds-from-epoch).\n\n    statresponder.file();   // Tells the statter to actually send the values above down the wire.\n});\n```\n\n#### File\n```js\nsession.on('stat', function(path, statkind, statresponder) {\n    statresponder.is_file();           // Tells statresponder that we're describing a file.\n    statresponder.permissions = 0o644; // Octal permissions, like what you'd send to a chmod command\n    statresponder.uid = 1;             // User ID that owns the file.\n    statresponder.gid = 1;             // Group ID that owns the file.\n    statresponder.size = 1234;         // File size in bytes.\n    statresponder.atime = 123456;      // Created at (unix style timestamp in seconds-from-epoch).\n    statresponder.mtime = 123456;      // Modified at (unix style timestamp in seconds-from-epoch).\n\n    statresponder.file();   // Tells the statter to actually send the values above down the wire.\n});\n```\n\n#### Errors\n\nYou can also respond with file not found messages like this:\n\n```js\nsession.on('stat', function(path, statkind, statresponder) {\n    statresponder.nofile(); // Tells the statter to send a file not found stat down the wire.\n});\n```\n\n`.on(\"readdir\", function (path, responder) { })` - on a directory listing attempt, the `responder` will\nkeep emitting `dir` messages, allowing you to respond with `responder.file(filename, attrs)` to return a file\nentry in the directory, or `responder.end()` if the directory listing is complete. See `server_example.js` for a\ncomplete example.\n\nSome explanation on `attrs` param:\n```js\nvar fs = require('fs');\n\n/*\n* Explanation for attrs.mode \n* \n* You may use type bit from fs lib constants and add permissions to it\n* \n* Permissions mask would look like 0oXXX where XXX is file octal permissions\n* \n* If you'd like to explain directory use:\n* fs.constants.S_IFDIR | 0oXXX\n* \n* If you'd like to explain file use:\n* fs.constants.S_IFREG | 0oXXX\n* \n*/\n\nvar attrs = {\n\t'mode': fs.constants.S_IFDIR | 0o644 \t// Bit mask of file type and permissions \n\t'permissions': 0o644, \t\t\t\t\t// Octal permissions, like what you'd send to a chmod command\n\t'uid': 1, \t\t\t\t\t\t\t\t// User ID that owns the file.\n\t'gid': 1, \t\t\t\t\t\t\t\t// Group ID that owns the file.\n\t'size': 1234, \t\t\t\t\t\t\t// File size in bytes.\n\t'atime': 123456, \t\t\t\t\t\t// Created at (unix style timestamp in seconds-from-epoch).\n\t'mtime': 123456 \t\t\t\t\t\t// Modified at (unix style timestamp in seconds-from-epoch).\n}\n\n```\n\n`.on(\"readfile\",function (path,writable_stream) { })` - the client is attempting to read a file\nfrom the server - place or pipe the contents of the file into the `writable_stream`.\n\n`.on(\"writefile\",function (path,readable_stream) { })` - the client is attempting to write a \nfile to the server - the `readable_stream` corresponds to the actual file. You\nmay `.pipe()` that into a writable stream of your own, or use it directly.\n\n`.on(\"delete\",function (path,callback) { })` - the client wishes to delete a file. Respond with\n`callback.ok()` or `callback.fail()` or any of the other error types\n\n`.on(\"rename\",function (oldPath,newPath,callback) { })` - the client wishes to rename a file. Respond with\n`callback.ok()` or `callback.fail()` or any of the other error types\n\n`.on(\"mkdir\",function (path,callback) { })` - the client wishes to create a directory. Respond with\n`callback.ok()` or `callback.fail()` or any of the other error types\n\n`.on(\"rmdir\",function (oldPath,callback) { })` - the client wishes to remove a directory. Respond with\n`callback.ok()` or `callback.fail()` or any of the other error types\n\n## Error Callbacks\n\nMany of the session events pass some kind of 'responder' or 'callback' object\nas a parameter. Those typically will have several error conditions that you can\nuse to refuse the request - \n\n- `responder.fail()` - general failure?\n- `responder.nofile()` - no such file or directory\n- `responder.denied()` - access denied\n- `responder.bad_message()` - protocol error; bad message (unusual)\n- `responder.unsupported()` - operation not supported\n- `responder.ok()` - success\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/BriteVerify/node-sftp-server.git"
  },
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "version": "0.3.0"
}
